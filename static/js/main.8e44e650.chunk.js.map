{"version":3,"sources":["Size.js","pose-detection/utilities.js","comparingDistance.js","pose-detection/Camera.js","pose-detection/WebcamExample.js","App.js","reducers/index.js","index.js"],"names":["Size","poses","pointIndex","adjacentPointIndex","keypoints","point","adjacentPoint","score_avg","console","log","second","substraction","reduce","acc","curr","i","sub","push","myX","myY","elementDistance","sqrt","COLOR","drawSkeleton","ctx","posedetection","getAdjacentPairs","BlazePose","forEach","j","kp1","kp2","score1","score","score2","beginPath","moveTo","x","y","lineTo","strokeStyle","stroke","drawKeypoints","minConfidence","scale","length","keypoint","drawPoint","r","color","arc","Math","PI","fillStyle","fill","t_shirt_array","half_span_arr","iterateSize","arr","result_arr","len","currentSize","e","clothes","Small","Medium","Large","XLarge","comparingDistance","height","size_factor","real_size","size_str","results_arr","tshirt_results_array","cv_distance","_","sum","map","property","w","h","comparing","undefined","Camera","videoConstraints","width","facingMode","WebcamCapture","useState","photo","setPhoto","setHeight","size","setSize","myImage","setMyImage","timer","setTimer","canvasRef","useRef","useEffect","myDetector","intervalId","setInterval","clearInterval","image","a","model","poseDetection","detectorConfig","runtime","enableSmoothing","modelType","detector","detect","estimationConfig","flipHorizontal","timestamp","performance","now","estimatePoses","distance","drawCanvas","message","webcamRef","React","capture","useCallback","imageSrc","current","getScreenshot","document","createElement","src","img","imgWidth","imgHeight","canvas","getContext","style","fontSize","className","audio","ref","screenshotFormat","id","position","marginLeft","marginRight","left","right","textAlign","zindex","justifyContent","type","onChange","target","value","borderStyle","borderColor","onClick","setTimeout","App","Component","combineReducers","store","createStore","reducers","composeWithDevTools","applyMiddleware","reduxThunk","ReactDOM","render","querySelector"],"mappings":"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","file":"static/js/main.8e44e650.chunk.js","sourcesContent":["import {sqrt} from 'mathjs'\r\n\r\nexport default function Size(poses, pointIndex, adjacentPointIndex) {\r\n\r\n    const substract = (first, second) =>\r\n        first.reduce((acc, curr, i) => {\r\n            const sub = curr - second[i];\r\n            acc.push(sub);\r\n            return acc;\r\n        }, []);\r\n\r\n\r\n\r\n    const keypoints = poses[\"0\"][\"keypoints\"];\r\n\r\n\r\n    const point = [keypoints[pointIndex][\"y\"],keypoints[pointIndex][\"x\"] ]\r\n    \r\n\r\n    const adjacentPoint = [keypoints[adjacentPointIndex][\"y\"], keypoints[adjacentPointIndex][\"x\"]]\r\n\r\n\r\n    // Score avg:\r\n    const score = keypoints[pointIndex][\"score\"]\r\n    const adjacentScore = keypoints[adjacentPointIndex][\"score\"]\r\n    const score_avg = (score+adjacentScore)/2\r\n    console.log(score_avg)\r\n    \r\n    const substraction = substract(point, adjacentPoint)\r\n    \r\n    const myX = substraction[1];\r\n    const myY = substraction[0]\r\n    const elementDistance = sqrt(myX^2+myY^2);\r\n\r\n\r\n\r\n    if(typeof(elementDistance) === 'number'){\r\n        return elementDistance\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import Size from '../Size';\r\n\r\nimport * as posedetection from '@tensorflow-models/pose-detection';\r\n\r\nconst COLOR = '#27d594';\r\nconst COLOR_LINE = 'gray'\r\n\r\n\r\n// (keypoints, minConfidence, ctx, scale = 1\r\n\r\n\r\nexport function drawSkeleton(keypoints, ctx) {\r\n    const adjacentKeyPoints =\r\n\r\n        posedetection.util.getAdjacentPairs(posedetection.SupportedModels.BlazePose);\r\n\r\n    adjacentKeyPoints.forEach(([\r\n                                                                      i, j\r\n                                                                    ]) => {\r\n      const kp1 = keypoints[i];\r\n      const kp2 = keypoints[j];\r\n\r\n      // If score is null, just show the keypoint.\r\n      const score1 = kp1.score != null ? kp1.score : 1;\r\n      const score2 = kp2.score != null ? kp2.score : 1;\r\n      const scoreThreshold = 0.65 || 0;\r\n\r\n      if (score1 >= scoreThreshold && score2 >= scoreThreshold) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(kp1.x, kp1.y);\r\n        ctx.lineTo(kp2.x, kp2.y);\r\n        ctx.strokeStyle = COLOR_LINE;\r\n        ctx.stroke();\r\n      }\r\n    });\r\n\r\n\r\n\r\n}\r\n  \r\n\r\nexport function drawKeypoints(keypoints, minConfidence, ctx, scale = 1) {\r\n    for (let i = 0; i < keypoints.length; i++) {\r\n        const keypoint = keypoints[i];\r\n    \r\n        if (keypoint.score < minConfidence) {\r\n            continue;\r\n        }\r\n\r\n        const x = keypoint.x;\r\n        const y = keypoint.y;\r\n\r\n        drawPoint(ctx, y * scale, x * scale, 3, COLOR);\r\n    }\r\n}\r\n\r\n\r\nexport function drawPoint(ctx, y, x, r, color) {\r\n    ctx.beginPath();\r\n    ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n    ctx.fillStyle = color;\r\n    ctx.fill();\r\n}\r\n  \r\n\r\n\r\nexport const blazeposearray = [[\"11\", \"12\"],[\"24\", \"23\"],[\"12\", \"24\"],[\"11\", \"23\"],[\"14\", \"16\"],[\"13\", \"15\"]]\r\n\r\nexport const t_shirt_array = [[\"11\", \"12\"],[\"12\", \"24\"] ]\r\n\r\nexport const arm_span_arr = [[\"12\", \"11\"], [\"14\", \"12\"], [\"14\", \"16\"], [\"16\", \"20\"], [\"11\", \"13\"], [\"13\", \"15\"], [\"15\", \"19\"]]\r\n\r\nexport const half_span_arr = [[\"14\", \"12\"], [\"14\", \"16\"], [\"16\", \"20\"]]\r\n\r\n\r\nexport function iterateSize(arr, poses) {\r\n\r\n    let result_arr = []\r\n    for(let i =0, len = arr.length; i<len; i++){\r\n        \r\n        let currentSize = Size(poses, arr[i][0], arr[i][1])\r\n\r\n\r\n        try{\r\n            result_arr.push(currentSize)\r\n         } catch(e){\r\n             console.log(\"This is an error\")\r\n         }\r\n\r\n\r\n\r\n    } \r\n\r\n    return result_arr\r\n}\r\n\r\n\r\nexport const clothes ={\r\n    Small: [43, 70],\r\n    Medium: [50, 76],\r\n    Large: [56, 77],\r\n    XLarge: [58, 80]\r\n}\r\n\r\n\r\n","import Size from \"./Size\";\r\nimport _ from 'lodash';\r\nimport {iterateSize, t_shirt_array } from \"./pose-detection/utilities\";\r\nimport { clothes } from \"./pose-detection/utilities\";\r\nimport {half_span_arr } from \"./pose-detection/utilities\";\r\n\r\n\r\n// Returns a string\r\n\r\nexport default function comparingDistance(poses, height){\r\n    \r\n    let size_factor = 0;\r\n    let real_size = [];\r\n    let size_str = \"First loading...\"\r\n    \r\n    let results_arr = iterateSize(half_span_arr, poses); //using just 1 arm\r\n    let tshirt_results_array = iterateSize(t_shirt_array, poses);\r\n    console.log(\"tshirt2: \"+tshirt_results_array.length)\r\n    console.log(\"results3: \"+results_arr.length)\r\n    console.log(\"Comparing height:\"+height)\r\n\r\n\r\n    if(results_arr.length ===3 && tshirt_results_array.length===2){ \r\n        const cv_distance = _.sum(results_arr)*2 + Size(poses, 11, 12);\r\n        size_factor = ((height)/cv_distance);\r\n\r\n        real_size= iterateSize(t_shirt_array, poses).map(x=>x*size_factor)\r\n\r\n\r\n        const comparing=(clothes, real_size)=>{\r\n            for (const property in clothes){\r\n                const w = clothes[property][0]-real_size[0];\r\n                const h = clothes[property][1]-real_size[1];\r\n\r\n                if(w<0 || h<0){\r\n                    continue;\r\n                } \r\n                const property_name = property;\r\n\r\n                return property_name\r\n            }\r\n        }\r\n\r\n        \r\n\r\n        size_str = comparing(clothes, real_size);\r\n\r\n        if(size_str !== undefined){\r\n            return size_str\r\n        }else{\r\n            size_str = \"Sorry we don't have it in your size :(\"\r\n            console.log(\"Sorry we don't have it in your size :(\")\r\n        }\r\n\r\n    }\r\n\r\n    return size_str;\r\n\r\n}","import React, { useRef, useState } from \"react\";\r\nimport {drawKeypoints, drawSkeleton } from \"./utilities\";\r\nimport Webcam from \"react-webcam\";\r\nimport * as poseDetection from '@tensorflow-models/pose-detection';\r\n\r\nimport '@tensorflow/tfjs-backend-webgl';\r\nimport comparingDistance from \"../comparingDistance\";\r\n\r\n\r\nfunction Camera (){\r\n    const webcamRef = useRef(null);\r\n    const canvasRef = useRef(null);\r\n\r\n    const [height, setHeight] = useState(0);\r\n    const [size, setSize] = useState()\r\n\r\n\r\n    // Load BlazePose\r\n\r\n    const myDetector= async ()=>{\r\n        const model = poseDetection.SupportedModels.BlazePose;\r\n        const detectorConfig = {\r\n        runtime: 'tfjs',\r\n        enableSmoothing: true,\r\n        modelType: 'full'\r\n        };\r\n        \r\n        const detector = await poseDetection.createDetector(model, detectorConfig);\r\n        \r\n        setInterval(() => {\r\n            detect(detector);\r\n          }, 100);\r\n    }\r\n\r\n    myDetector();\r\n\r\n    const detect = async (detector)=>{\r\n        if (\r\n            typeof webcamRef.current !== \"undefined\" &&\r\n            webcamRef.current !== null &&\r\n            webcamRef.current.video.readyState === 4\r\n          ) {\r\n            // Get Video Properties\r\n            const video = webcamRef.current.video;\r\n            const videoWidth = webcamRef.current.video.videoWidth;\r\n            const videoHeight = webcamRef.current.video.videoHeight;\r\n      \r\n            // Set video width\r\n            webcamRef.current.video.width = videoWidth;\r\n            webcamRef.current.video.height = videoHeight;\r\n      \r\n            // Make Detections\r\n            // const pose = await net.estimateSinglePose(video);\r\n\r\n            const estimationConfig = {flipHorizontal:true}\r\n            const timestamp = performance.now();\r\n            const poses = await detector.estimatePoses(video, estimationConfig, timestamp)\r\n            \r\n            \r\n            // console.log(poses[\"0\"][\"keypoints\"]);\r\n            try {\r\n              drawCanvas(poses, video, videoWidth, videoHeight, canvasRef);\r\n              const distance = comparingDistance(poses, height);\r\n              if(distance == 'Small'|'Medium'|'Large'|'Xlarge'){\r\n                setSize(distance);\r\n              }\r\n              // console.log((comparingDistance(poses, height)));\r\n            } catch (e) {\r\n              console.error(e.message);\r\n              // setSize(\"Loading...\")\r\n            }            \r\n          }\r\n    }\r\n\r\n    const drawCanvas = (poses, video, videoWidth, videoHeight, canvas)=>{\r\n        const ctx =  canvas.current.getContext(\"2d\");\r\n        canvas.current.width = videoWidth;\r\n        canvas.current.height = videoHeight;\r\n\r\n        drawKeypoints(poses[\"0\"][\"keypoints\"], 0.6, ctx);\r\n        drawSkeleton(poses[\"0\"][\"keypoints\"], ctx);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    return(\r\n        <div>\r\n          <Webcam \r\n            ref = {webcamRef}\r\n            style = {{\r\n              position: 'absolute', \r\n              marginLeft:\"auto\",\r\n              marginRight: \"auto\",\r\n              left: 0,\r\n              right:0,\r\n              textAlign: 'center',\r\n              zindex: 9,\r\n              width: 640,\r\n              height:480\r\n          }}\r\n          />\r\n    \r\n          <canvas \r\n            ref = {canvasRef}\r\n            style = {{\r\n              position: \"absolute\",\r\n              marginLeft: \"auto\",\r\n              marginRight: \"auto\",\r\n              left: 0,\r\n              right:0,\r\n              textAlign: 'center',\r\n              zindex: 9,\r\n              width: 640,\r\n              height:480\r\n          }}\r\n          />\r\n          <div\r\n            style= {{\r\n\r\n              position:'relative',\r\n              marginLeft:'auto',\r\n              marginRight: \"auto\",\r\n              justifyContent: 'flex-end',\r\n              padding:500\r\n            }}  \r\n          >\r\n            <label>What's your height? (cm) </label>\r\n            <input \r\n              type={\"number\"} \r\n              onChange={e=>setHeight(e.target.value)}\r\n              style={{\r\n                borderStyle: 'groove',\r\n                borderColor: 'gray'\r\n              }} \r\n            />\r\n            <h2>\r\n            Your size should be:\r\n            </h2>\r\n            <h3>\r\n            {size}\r\n            </h3>\r\n          </div>\r\n\r\n          \r\n\r\n          \r\n        </div>\r\n      )\r\n\r\n}\r\n\r\nexport default Camera;","import React, { useEffect, useRef, useState } from \"react\";\r\nimport Webcam from \"react-webcam\";\r\nimport comparingDistance from \"../comparingDistance\";\r\n\r\n\r\nimport * as poseDetection from '@tensorflow-models/pose-detection';\r\nimport '@tensorflow/tfjs-backend-webgl';\r\n\r\nimport { drawKeypoints, drawSkeleton } from \"./utilities\";\r\n\r\nconst videoConstraints = {\r\n    width: 640,\r\n    height:480,\r\n    facingMode: \"user\"\r\n};\r\n\r\nconst WebcamCapture = ()=>{\r\n    const [photo, setPhoto] = useState('');\r\n    const [height, setHeight] = useState(0);\r\n    const [size, setSize] = useState();\r\n    const [myImage, setMyImage] = useState();\r\n    const [timer, setTimer] = useState(null);\r\n    \r\n\r\n    const canvasRef = useRef(null);\r\n\r\n\r\n    useEffect(\r\n        ()=>{\r\n            myDetector(myImage);\r\n        },[photo]\r\n    )\r\n\r\n    useEffect(\r\n        ()=>{\r\n            \r\n            if (timer ===0){\r\n                setTimer(null);\r\n            }\r\n\r\n            if(!timer) return;\r\n\r\n            const intervalId = setInterval(()=>{\r\n                setTimer(timer-1);\r\n            }, 1000);\r\n\r\n            return ()=>clearInterval(intervalId);\r\n        }, [timer]);\r\n\r\n\r\n\r\n    const myDetector = async(image)=>{\r\n        const model = poseDetection.SupportedModels.BlazePose;\r\n        const detectorConfig={\r\n            runtime: 'tfjs',\r\n            enableSmoothing: true,\r\n            modelType: 'full'\r\n        };\r\n\r\n        const detector = await poseDetection.createDetector(model, detectorConfig);\r\n\r\n        detect(detector, image);\r\n\r\n\r\n    }\r\n    \r\n\r\n    \r\n    const detect = async(detector, image)=>{\r\n\r\n        if(typeof (photo) !==\"\"){\r\n\r\n            const estimationConfig = {flipHorizontal:true}\r\n            const timestamp = performance.now();\r\n\r\n            const poses = await detector.estimatePoses(image, estimationConfig, timestamp)\r\n\r\n            try{\r\n                const distance = comparingDistance(poses, height);\r\n                console.log(distance)\r\n                \r\n                drawCanvas(poses, image, videoConstraints.width, videoConstraints.height, canvasRef);\r\n\r\n                setSize(distance)\r\n            }catch(e){\r\n                console.log(e.message)\r\n            }\r\n        }\r\n\r\n        \r\n    }\r\n\r\n\r\n    const webcamRef = React.useRef(null)\r\n\r\n    const handleClick =()=>{\r\n        setTimer(3);\r\n\r\n        setTimeout(()=>{\r\n            capture();\r\n        }, 3000)\r\n    }\r\n    \r\n    const capture = React.useCallback(\r\n        ()=>{\r\n            const imageSrc = webcamRef.current.getScreenshot();\r\n            \r\n            setPhoto(imageSrc);\r\n            \r\n            const image = document.createElement(\"img\");\r\n            image.src = imageSrc\r\n            image.width = 640\r\n            image.height = 480\r\n            \r\n\r\n            setMyImage(image);  \r\n    \r\n        },\r\n        [webcamRef]\r\n    );\r\n\r\n\r\n    const drawCanvas = (poses, img, imgWidth, imgHeight, canvas)=>{\r\n        const ctx =  canvas.current.getContext(\"2d\");\r\n        canvas.current.width = imgWidth;\r\n        canvas.current.height = imgHeight;\r\n\r\n        drawKeypoints(poses[\"0\"][\"keypoints\"], 0.6, ctx);\r\n        drawSkeleton(poses[\"0\"][\"keypoints\"], ctx);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    return(\r\n        <div>\r\n            <h3 style={{fontSize:32}}>{timer}</h3>\r\n            <div className=\"webcam-container\">\r\n                <div className=\"webcam-img\">\r\n\r\n                    {photo == ''? <Webcam\r\n                        audio = {false}\r\n                        height= {480}\r\n                        ref = {webcamRef}\r\n                        screenshotFormat= \"image/jpeg\"\r\n                        width={640}\r\n                        videoConstraints= {videoConstraints}\r\n                        />: <img src = {photo} id ={photo} />\r\n                    }\r\n                    <canvas\r\n                        ref = {canvasRef}\r\n                        style = {{\r\n                        position: \"absolute\",\r\n                        marginLeft: \"auto\",\r\n                        marginRight: \"auto\",\r\n                        left: 0,\r\n                        right:0,\r\n                        textAlign: 'center',\r\n                        zindex: 9,\r\n                        width: 640,\r\n                        height:480\r\n                        }}\r\n                    />\r\n                </div>\r\n\r\n            </div>\r\n\r\n\r\n            <div\r\n            style= {{\r\n\r\n              position:'relative',\r\n              marginLeft:'auto',\r\n              marginRight: \"auto\",\r\n              justifyContent: 'flex-end',\r\n           \r\n            }}  \r\n          >\r\n            <label>What's your height? (cm) </label>\r\n            <input \r\n              type={\"number\"} \r\n              onChange={e=>setHeight(e.target.value)}\r\n              style={{\r\n                borderStyle: 'groove',\r\n                borderColor: 'gray'\r\n              }} \r\n            />\r\n            \r\n            <h2>\r\n            Your size should be:\r\n            </h2>\r\n            <h3>\r\n                {size}\r\n            </h3>\r\n          </div>\r\n            <button onClick={handleClick}>Capture photo</button>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default WebcamCapture;\r\n","import React from 'react';\r\nimport Camera from './pose-detection/Camera';\r\nimport './App.css';\r\nimport Webcam from 'react-webcam';\r\nimport WebcamCapture from './pose-detection/WebcamExample'; \r\n\r\n\r\n\r\nclass App extends React.Component{\r\n\r\n    render(){\r\n        return(\r\n            <div >\r\n                <h1 style={{textAlign: 'center'}}>\r\n                    Welcome to Mirror Size!\r\n                </h1>\r\n                Checkout what would be your best fit!\r\n                {/* <Camera/> */}\r\n                <WebcamCapture/>\r\n                \r\n            </div>\r\n\r\n        )\r\n    }\r\n}\r\n\r\nexport default App;","import {combineReducers} from 'redux';\r\n\r\n\r\n\r\nexport default combineReducers({\r\n\r\n});","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\nimport { Provider } from 'react-redux';\r\nimport { createStore, applyMiddleware } from 'redux';\r\nimport reduxThunk from 'redux-thunk';\r\n\r\nimport App from './App';\r\nimport reducers from './reducers';\r\nimport { composeWithDevTools } from 'redux-devtools-extension';\r\nimport './App.css';\r\n\r\n\r\n\r\nconst store = createStore(reducers, {}, composeWithDevTools(applyMiddleware(reduxThunk)));\r\n\r\nReactDOM.render(<Provider store = {store}><App/></Provider> , document.querySelector('#root'));\r\n"],"sourceRoot":""}